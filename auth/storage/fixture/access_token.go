// Code generated by sqlc-fixture plugin for SQLc. DO NOT EDIT.

package fixture

import (
	"context"
	"github.com/go-modulus/modulus/auth/storage"
	uuid "github.com/gofrs/uuid"
	null "gopkg.in/guregu/null.v4"
	"testing"
	"time"
)

type AccessTokenFixture struct {
	entity storage.AccessToken
	db     storage.DBTX
}

func NewAccessTokenFixture(db storage.DBTX, defaultEntity storage.AccessToken) *AccessTokenFixture {
	return &AccessTokenFixture{
		db:     db,
		entity: defaultEntity,
	}
}

func (f *AccessTokenFixture) Hash(hash string) *AccessTokenFixture {
	c := f.clone()
	c.entity.Hash = hash
	return c
}

func (f *AccessTokenFixture) IdentityID(identityID uuid.UUID) *AccessTokenFixture {
	c := f.clone()
	c.entity.IdentityID = identityID
	return c
}

func (f *AccessTokenFixture) SessionID(sessionID uuid.UUID) *AccessTokenFixture {
	c := f.clone()
	c.entity.SessionID = sessionID
	return c
}

func (f *AccessTokenFixture) UserID(userID uuid.UUID) *AccessTokenFixture {
	c := f.clone()
	c.entity.UserID = userID
	return c
}

func (f *AccessTokenFixture) Roles(roles []string) *AccessTokenFixture {
	c := f.clone()
	c.entity.Roles = roles
	return c
}

func (f *AccessTokenFixture) Data(data []byte) *AccessTokenFixture {
	c := f.clone()
	c.entity.Data = data
	return c
}

func (f *AccessTokenFixture) RevokedAt(revokedAt null.Time) *AccessTokenFixture {
	c := f.clone()
	c.entity.RevokedAt = revokedAt
	return c
}

func (f *AccessTokenFixture) ExpiresAt(expiresAt time.Time) *AccessTokenFixture {
	c := f.clone()
	c.entity.ExpiresAt = expiresAt
	return c
}

func (f *AccessTokenFixture) CreatedAt(createdAt time.Time) *AccessTokenFixture {
	c := f.clone()
	c.entity.CreatedAt = createdAt
	return c
}

func (f *AccessTokenFixture) clone() *AccessTokenFixture {
	return &AccessTokenFixture{
		db:     f.db,
		entity: f.entity,
	}
}

func (f *AccessTokenFixture) save(ctx context.Context) error {
	query := `INSERT INTO auth.access_token
            (hash, identity_id, session_id, user_id, roles, data, revoked_at, expires_at, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING hash, identity_id, session_id, user_id, roles, data, revoked_at, expires_at, created_at
        `
	row := f.db.QueryRow(ctx, query,
		f.entity.Hash,
		f.entity.IdentityID,
		f.entity.SessionID,
		f.entity.UserID,
		f.entity.Roles,
		f.entity.Data,
		f.entity.RevokedAt,
		f.entity.ExpiresAt,
		f.entity.CreatedAt,
	)
	err := row.Scan(
		&f.entity.Hash,
		&f.entity.IdentityID,
		&f.entity.SessionID,
		&f.entity.UserID,
		&f.entity.Roles,
		&f.entity.Data,
		&f.entity.RevokedAt,
		&f.entity.ExpiresAt,
		&f.entity.CreatedAt,
	)
	return err
}

func (f *AccessTokenFixture) GetEntity() storage.AccessToken {
	return f.entity
}

func (f *AccessTokenFixture) Create(tb testing.TB) *AccessTokenFixture {
	err := f.save(context.Background())
	if err != nil {
		tb.Fatalf("failed to create AccessToken: %v", err)
	}
	f.Cleanup(tb)
	c := f.clone()
	return c
}

// Cleanup calls testing.TB.Cleanup() function with providing a callback inside it.
// This callback will delete a record from the table by primary key when test will be finished.
func (f *AccessTokenFixture) Cleanup(tb testing.TB) *AccessTokenFixture {
	tb.Cleanup(
		func() {
			query := `DELETE FROM auth.access_token WHERE hash = $1`
			_, err := f.db.Exec(context.Background(), query, f.entity.Hash)

			if err != nil {
				tb.Fatalf("failed to cleanup AccessToken: %v", err)
			}
		})

	return f
}

func (f *AccessTokenFixture) PullUpdates(tb testing.TB) *AccessTokenFixture {
	c := f.clone()
	ctx := context.Background()
	query := `SELECT * FROM auth.access_token WHERE hash = $1`
	row := f.db.QueryRow(ctx, query,
		c.entity.Hash,
	)

	err := row.Scan(
		&c.entity.Hash,
		&c.entity.IdentityID,
		&c.entity.SessionID,
		&c.entity.UserID,
		&c.entity.Roles,
		&c.entity.Data,
		&c.entity.RevokedAt,
		&c.entity.ExpiresAt,
		&c.entity.CreatedAt,
	)
	if err != nil {
		tb.Fatalf("failed to actualize data AccessToken: %v", err)
	}
	return c
}

func (f *AccessTokenFixture) PushUpdates(tb testing.TB) *AccessTokenFixture {
	c := f.clone()
	query := `
        UPDATE auth.access_token SET 
            identity_id = $2,
            session_id = $3,
            user_id = $4,
            roles = $5,
            data = $6,
            revoked_at = $7,
            expires_at = $8,
            created_at = $9
        WHERE hash = $1
        `
	_, err := f.db.Exec(
		context.Background(),
		query,
		f.entity.Hash,
		f.entity.IdentityID,
		f.entity.SessionID,
		f.entity.UserID,
		f.entity.Roles,
		f.entity.Data,
		f.entity.RevokedAt,
		f.entity.ExpiresAt,
		f.entity.CreatedAt,
	)
	if err != nil {
		tb.Fatalf("failed to push the data AccessToken: %v", err)
	}
	return c
}
